<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Virtual Population analysis using eXtended Survivor Analysis</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/yeti.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>








<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="http://flr-project.org">
    <span class="fa fa-home"></span>
     
    FLR
  </a>
</li>
<li>
  <a href="index.html">
    <span class="fa fa-info"></span>
     
    Home
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-play-circle-o"></span>
     
    Intro
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="A_quick_introduction_to_FLR.html">A quick introduction to FLR</a>
    </li>
    <li>
      <a href="An_overview_of_the_FLCore_classes.html">An overview of the FLCore classes</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-database"></span>
     
    Input
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Loading_your_data_into_FLR.html">Loading your data into FLR</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-magic"></span>
     
    Modelling
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Modelling_stock_recruitment_with_FLSR.html">Modelling stock recruitment with FLSR</a>
    </li>
    <li>
      <a href="Statistical_catch_at_age_models_in_FLa4a.html">Statistical catch at age models in FLa4a</a>
    </li>
    <li>
      <a href="Modelling_growth_and_its_uncertainty_in_FLa4a.html">Modelling growth and its uncertainty in FLa4a</a>
    </li>
    <li>
      <a href="Natural_mortality_modelling_in_FLa4a.html">Natural mortality modelling in FLa4a</a>
    </li>
    <li>
      <a href="Stock_assessment_using_eXtended_Survivors_Analysis_with_FLXSA.html">Stock assessment using eXtended Survivors Analysis with FLXSA</a>
    </li>
    <li>
      <a href="Using_information_on_life_history_relationships.html">Using information on Life History relationships</a>
    </li>
    <li>
      <a href="Life_history_relationships.html">Life history relationships</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-tachometer"></span>
     
    Advice
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Running_Medium_Term_Forecasts_with_FLash.html">Running Medium Term Forecasts with FLash</a>
    </li>
    <li>
      <a href="Short_Term_Forecasting_for_advice_using_FLash.html">Short Term Forecasting for advice using FLash</a>
    </li>
    <li>
      <a href="Forecasting_on_the_Medium_Term_for_advice_using_FLasher.html">Forecasting on the Medium Term for advice using FLasher</a>
    </li>
    <li>
      <a href="Reference_points_for_fisheries_management_with_FLBRP.html">Reference points for fisheries management with FLBRP</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-cogs"></span>
     
    MSE
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="An_introduction_to_MSE_using_FLR.html">An introduction to MSE using FLR</a>
    </li>
    <li>
      <a href="Management_procedure_biomass_dynamic.html">Biomass Dynamic Management Procedures</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-cogs"></span>
     
    FLBEIA
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="An_introduction_to_MSE_using_FLR.html">An introduction to MSE using FLR</a>
    </li>
    <li>
      <a href="FLBEIA_Conditioning.html">Conditioning FLBEIA using Smart Conditioning Functions</a>
    </li>
    <li>
      <a href="FLBEIA_A_Simple_Example.html">A simple example on how to use FLBEIA</a>
    </li>
    <li>
      <a href="FLBEIA_An_Example_with_multiple_dimensions.html">A simple example with multiple dimensions in FLBEIA</a>
    </li>
    <li>
      <a href="FLBEIA_Checking_inputs.html">Checking FLBEIA inputs</a>
    </li>
    <li>
      <a href="FLBEIA_Using_Assessment_models_in_the_MP.html">Using Stock Assessment models in the Management procedure of FLBEIA</a>
    </li>
    <li>
      <a href="FLBEIA_Incorporating_SS3assessment_MP.html">Including SS3 assessment within the Management Procedure of FLBEIA</a>
    </li>
    <li>
      <a href="FLBEIA_Testing_Management_Strategies.html">Testing different Management Strategies in FLBEIA</a>
    </li>
    <li>
      <a href="FLBEIA_Data_Poor_MSE.html">Data Limited MSE in FLBEIA</a>
    </li>
    <li>
      <a href="FLBEIA_Smart_Conditioning_II.html">Smart Conditioning II</a>
    </li>
    <li>
      <a href="FLBEIA_Mixed_Fisheries_Tutorial.html">ICES Mixed Fisheries Advice using FLBEIA</a>
    </li>
    <li>
      <a href="FLBEIA_Bio_Economic_Tutorial.html">Bio-Economic simulation using FLBEIA</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-area-chart"></span>
     
    Plotting
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="ggplotFL_plotting_FLR_objects_with_ggplot2.html">ggplotFL, plotting FLR objects with ggplot2</a>
    </li>
    <li>
      <a href="Plotting_FLR_objects_using_lattice.html">Plotting FLR objects using lattice</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-puzzle-piece"></span>
     
    Internals
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Units_of_measurement_in_FLR_objects.html">Units of measurement in FLR objects</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="http://github.com/flr/doc/issues">
    <span class="fa fa-question fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Virtual Population analysis using eXtended Survivor Analysis</h1>
<h4 class="date">04 July, 2021</h4>

</div>


<div id="required-packages" class="section level2">
<h2>Required packages</h2>
<p>To follow this tutorial you should have installed the following packages:</p>
<ul>
<li>FLR: <a href="http://www.flr-project.org/FLCore/">FLCore</a>, <a href="http://www.flr-project.org/FLAssess/">FLAssess</a>, <a href="http://www.flr-project.org/FLXSA/">FLXSA</a>, <a href="http://www.flr-project.org/ggplotFL/">ggplotFL</a></li>
<li>CRAN: [reshape] You can do so as follows,</li>
</ul>
<pre class="r"><code>install.packages(c(&quot;FLCore&quot;, &quot;FLAssess&quot;, &quot;FLXSA&quot;), repos=&quot;http://flr-project.org/R&quot;)</code></pre>
<pre class="r"><code># This chunk loads all necessary packages, trims pkg messages
library(FLCore)
library(FLAssess)
library(FLXSA)</code></pre>
</div>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<div id="what-is-vpa" class="section level2">
<h2>What is VPA</h2>
<p>Virtual population analysis (VPA) is a modeling technique commonly used in fisheries science for reconstructing the historical population structure of an age structured fish stock using information on the deaths of individuals in each time step. The time steps are typically, though not necessarily, annual and the deaths are usually partitioned into mortality due to fishing and natural mortality. In some instances natural mortality may be further partitioned into predation mortality and mortality from other causes, such as disease, senesence etc.</p>
<p>VPA is the most commonly used term to refer to cohort reconstruction techniques used in fisheries. It is virtual in the sense that the population size is not observed or measured directly but is inferred or backcalculated to have been a certain size in the past. Several different software implementations of cohort reconstruction for fish populations exist including ADAPT which is often used in Canada and the USA and XSA <span class="citation">(Shepherd 1999)</span> which is commonly used in Europe. The back-calculations in these implementations work the same way but they differ in the statistical methods used for “tuning” to indices of population size. Tuning refers to the use of auxilliary information to determine the terminal fishing mortalities and population numbers. Most tuning approaches involve a regression of fishing mortality against fishing effort to estimate population abundance at age through an iterative convergence to some threshold criterion. Relatively simple techniques, the Laurec-Shepherd method <span class="citation">(<span class="citeproc-not-found" data-reference-id="pope1985"><strong>???</strong></span>)</span> for example, have been shown to work well with simulated data but there is little theoretical work to justify or validate these approaches <span class="citation">(II and Deriso 1999)</span>.</p>
<p>A number of assessment methods are made available in FLR as well as the basic VPA tools to enable you to develop your own assessment methods. In this tutorial we will cover the basic VPA tools, simple methods for tuning a VPA and finally show how to run <strong>FLXSA</strong>.</p>
</div>
<div id="stock-assessment-methods-within-the-flr-package-structure" class="section level2">
<h2>Stock assessment methods within the FLR package structure</h2>
<p>The package <strong>FLAssess</strong> contains the basic class for age and biomass based stock assessments. It provides a standard class, <strong>FLAssess</strong>, for data input,<br />
stock status estimation and diagnostic inspection. The <strong>FLAssess</strong> package has a variety of uses. It can be applied within a stock assessment working group setting or, alternatively, as part of the management procedure in a formal Management Strategy Evaluation (MSE). FLAssess provides a common interface for existing stock assessment methods (e.g. XSA) allowing methods to be used interchangeably. It also includes various methods of general use such as setting up a short-term forecast (<code>stf</code>), running VPAs (<code>VPA</code> or <code>SepVPA</code>) and calculating F from catches. There are several steps to be completed when conducting an assessment. This tutorial considers only the process of running <code>VPA</code> and <code>FLXSA</code> stock assessment model.<br />
<a href="http://flr-project.org/doc">Additional tutorials</a> are available that will introduce you to other parts of the <strong>FLR</strong> toolset.</p>
<p>We will start by importing the data sets for the North Sea Plaice stock and the fishery independent abundance indices. We will use these example data sets for all of the examples in this tutorial.</p>
<pre class="r"><code>data(ple4)
data(ple4.indices)</code></pre>
<p>The North Sea Plaice <code>FLStock</code> object already has values estimated for harvest and stock numbers. We should remove these first and replace them with <code>NA</code>.</p>
<pre class="r"><code>harvest(ple4)[] &lt;- NA
stock.n(ple4)[] &lt;- NA</code></pre>
<p>We should note at this point that the example below should not be considered the definitive assessment for the North Sea Plaice. We provide this example merely to show the procedure for conducting assessments using FLR.</p>
</div>
</div>
<div id="the-vpa-method" class="section level1">
<h1>The VPA method</h1>
<p>The <code>VPA</code> method implements Pope’s Virtual Population Analysis (VPA). It is called with the command VPA which returns an object of class <code>FLVPA</code> that is itself an extension of the <code>FLAssess</code> class. The <code>VPA</code> method estimates population numbers and fishing mortalities at age by back-calculating values down each cohort. To do this, the method requires initial values of harvest for the terminal age and terminal year in the <code>FLStock</code> object. These terminal values must be specified by the user prior to running the <code>VPA</code>. The arguments to the <code>VPA</code> method are the <code>FLStock</code> object for which values are to be calculated and two optional arguments.</p>
<p>The range method will show details of the age and year range of the <code>ple4</code> <code>FLStock</code> object. We can use this information to manually specify the terminal values in the harvest slot. In this instance we will set these<br />
values to 1.0. Remember to convert the values to be of type character when indexing the <code>FLQuants</code>.</p>
<pre class="r"><code>harvest(ple4)[ac(range(ple4)[&quot;max&quot;]), ]     &lt;- 1
harvest(ple4)[, ac(range(ple4)[&quot;maxyear&quot;])] &lt;- 1

ple4.vpa &lt;- VPA(ple4, fratio = 1, fit.plusgroup = T)
ple4.new &lt;- ple4 + ple4.vpa

## Have a look in stock number ##
stock.n(ple4.vpa)[, ac(2005:range(ple4)[&quot;maxyear&quot;])]</code></pre>
<pre><code>An object of class &quot;FLQuant&quot;
, , unit = unique, season = all, area = unique

    year
age  2005      2006      2007      2008      2009      2010      2011     
  1   727422.7  714089.7 1080988.1  860680.4  811461.7 1061031.1 1148353.6
  2   740467.9  494608.8  505294.6  796821.9  631147.0  575619.3  762530.4
  3   190271.1  413340.6  281588.2  289082.4  475010.1  402704.6  386692.2
  4   273062.5   92337.1  200594.2  134282.1  147948.4  272930.1  245506.7
  5    45186.6  135618.8   47632.4  106297.1   72270.2   80610.3  150395.0
  6    34257.0   22604.0   72879.2   27001.3   61282.3   41221.8   44890.0
  7    15049.4   17133.2   12161.7   40948.6   15756.0   36685.1   24284.4
  8     7415.5    8112.3    9645.0    6851.3   23432.2    9331.3   22231.0
  9     8478.0    4526.7    5157.5    6235.4    4486.5   15571.3    6298.0
  10    5270.4    9513.7   10261.4   11855.6   14230.4   14703.3   23426.0
    year
age  2012      2013      2014      2015      2016      2017     
  1   889512.4  971160.1 1024564.4  488076.4  396779.2  189714.5
  2   883818.9  711636.0  755794.7  728978.7  320424.8  236873.2
  3   523353.9  604586.3  475967.2  484846.7  444943.1  182714.8
  4   230998.4  299022.9  341507.5  272373.6  268931.6  217290.6
  5   135024.8  124247.2  157044.0  176299.0  138428.9  124591.1
  6    80728.3   69083.3   61061.0   76403.8   84867.4   63401.4
  7    24682.3   41024.4   33728.5   28953.6   34952.6   35366.6
  8    14657.1   14415.4   22299.4   16289.6   11853.3   12982.4
  9    15148.4    9809.2    8957.9   12073.5    7364.8    4233.0
  10   22469.5   27525.0   26113.7   23046.2   21101.0   14646.2

units:  1000 </code></pre>
<pre class="r"><code>## Have a look in fishing mortality ##
harvest(ple4.vpa)[, ac(2004:range(ple4)[&quot;maxyear&quot;])]</code></pre>
<pre><code>An object of class &quot;FLQuant&quot;
, , unit = unique, season = all, area = unique

    year
age  2004    2005    2006    2007    2008    2009    2010    2011    2012   
  1  0.26372 0.28574 0.24587 0.20500 0.21018 0.24339 0.23035 0.16183 0.12311
  2  0.54862 0.48301 0.46332 0.45843 0.41730 0.34934 0.29782 0.27638 0.27971
  3  0.73103 0.62300 0.62299 0.64050 0.56985 0.45412 0.39488 0.41522 0.45974
  4  0.64361 0.59985 0.56193 0.53505 0.51953 0.50724 0.49595 0.49787 0.52014
  5  0.64425 0.59268 0.52104 0.46763 0.45075 0.46144 0.48541 0.52218 0.57014
  6  0.70361 0.59288 0.51983 0.47648 0.43866 0.41312 0.42913 0.49813 0.57692
  7  0.65271 0.51795 0.47458 0.47385 0.45821 0.42384 0.40088 0.40491 0.43779
  8  0.48009 0.39359 0.35292 0.33619 0.32338 0.30868 0.29314 0.28359 0.30160
  9  0.29044 0.26820 0.21355 0.16280 0.14003 0.14135 0.15646 0.17980 0.21238
  10 0.29044 0.26820 0.21355 0.16280 0.14003 0.14135 0.15646 0.17980 0.21238
    year
age  2013    2014    2015    2016    2017   
  1  0.15072 0.24038 0.32082 0.41586 1.00000
  2  0.30222 0.34394 0.39370 0.46172 1.00000
  3  0.47117 0.45817 0.48938 0.61671 1.00000
  4  0.54399 0.56119 0.57682 0.66942 1.00000
  5  0.61040 0.62049 0.63109 0.68087 1.00000
  6  0.61697 0.64618 0.68204 0.77532 1.00000
  7  0.50961 0.62781 0.79309 0.89040 1.00000
  8  0.37576 0.51355 0.69381 0.92970 1.00000
  9  0.25745 0.31989 0.40944 0.56452 1.00000
  10 0.25745 0.31989 0.40944 0.56452 1.00000

units:  f </code></pre>
<pre class="r"><code>## Plot results ##
plot(FLStocks(ple4=ple4, vpa=ple4.new))</code></pre>
<p><img src="Stock_assessment_using_eXtended_Survivors_Analysis_with_FLXSA_files/figure-html/unnamed-chunk-6-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>plot(FLStocks(vpa=ple4.new))</code></pre>
<p><img src="Stock_assessment_using_eXtended_Survivors_Analysis_with_FLXSA_files/figure-html/unnamed-chunk-6-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>The estimated population numbers and fishing mortality values at age from the <code>VPA</code> are now available in the returned object. Note that the terminal values for fishing mortalty are the user defined values that were specified prior to running the <code>VPA</code>.</p>
</div>
<div id="a-simple-method-for-tuning-a-vpa" class="section level1">
<h1>A simple method for tuning a VPA</h1>
<p>As noted above the VPA method requires user defined terminal estimates of fishing mortality. This dependency limits the usefulness of the method since it is often the most recent, terminal, estimates that are of most concern to fishery managers. Additional catch at age and effort information, derived either from a sub component of the fishery or from a fishery independent source such as a research survey, can be used to ‘tune’ the assessment, as described above, and thereby obtain better estimates of fishing mortality and stock numbers in the most recent years. Several so-called ad hoc techniques for tuning a VPA have been developed. A relatively simple technique that has been widely used is the Laurec Shepherd method. This method can be easily implemented in FLR using the basic VPA tools that are provided in the <strong>FLAssess</strong> package.</p>
<p>The example shown below is a simple implementation that allows for a single tuning fleet. With a little extra effort it could be easily extended to accomodate multiple tuning fleets. The technical details of the method are not explained here.</p>
<pre class="r"><code># Define Laurec-Sheperd function #

lsm &lt;- function(stock, index, fratio = 1, fit.plusgroup = T) {
  harvest(stock)[, ac(range(stock)[&quot;maxyear&quot;])] &lt;- 0.5
  diff &lt;- 1
  while (diff &gt; 1e-06) {
    stock &lt;- stock + VPA(stock, fratio = fratio)
    ages  &lt;- range(index)[&quot;min&quot;]:range(index)[&quot;max&quot;]
    yrs   &lt;- range(index)[&quot;minyear&quot;]:range(index)[&quot;maxyear&quot;]
    stk   &lt;- trim(stock, year = yrs, age = ages)
    Cp    &lt;- catch.n(index)/catch.n(stk)
    q     &lt;- sweep(Cp * harvest(stk), 2, effort(index), &quot;/&quot;)
    gmq   &lt;- apply(q, 1, function(x) exp(mean(log(x), na.rm = T)))
    mFp   &lt;- gmq * c(apply(effort(index), 1, mean))
    Fr    &lt;- mFp * (apply(Cp, 1, mean, na.rm = T))^-1
    Fnew  &lt;- c(Fr, rep(Fr[ac(max(ages)), ], 1))
    diff  &lt;- sum(abs(harvest(stock)[, ac(range(stock)[&quot;maxyear&quot;])] -
                        Fnew))
    harvest(stock)[, ac(range(stock)[&quot;maxyear&quot;])] &lt;- c(Fnew)
    }
  res &lt;- VPA(stock, fratio = fratio, fit.plusgroup = fit.plusgroup)
  index.res(res) &lt;- FLQuants(q)
  return(res)
  }</code></pre>
<p>The new Laurec-Shepherd function can now be called without having to specify terminal values in the harvest slot. The arguments to the <code>VPA</code> method are also formally declared as arguments to our new function. Note that the function returns an object of class <code>FLVPA</code> that has been created from a call to the <code>VPA</code> method and that the catchability residuals are stored in the <code>index.res</code> slot of the returned object.</p>
<pre class="r"><code>harvest(ple4)[] &lt;- NA
stock.n(ple4)[] &lt;- NA

ple4.LSvpa &lt;- lsm(ple4, ple4.indices[[1]], fratio = 1, fit.plusgroup = T)

ple4.new2 &lt;- ple4 + ple4.LSvpa

stock.n(ple4.LSvpa)[, ac(2005:range(ple4)[&quot;maxyear&quot;])]</code></pre>
<pre><code>An object of class &quot;FLQuant&quot;
, , unit = unique, season = all, area = unique

    year
age  2005      2006      2007      2008      2009      2010      2011     
  1   731905.9  719384.2 1090813.8  869716.2  820615.7 1089763.0 1181196.2
  2   745531.6  498662.7  510082.8  805709.5  639320.0  583898.2  788517.0
  3   191861.1  417913.5  285249.8  293407.5  483040.5  410092.4  394177.8
  4   276099.6   93771.2  204718.7  137584.1  151851.6  280184.0  252183.0
  5    45872.9  138358.7   48926.7  110020.5   75251.5   84134.6  156945.6
  6    35005.9   23223.2   75353.0   28170.3   64645.8   43914.8   48073.1
  7    15524.6   17808.8   12720.8   43182.9   16812.2   39724.5   26717.7
  8     7719.9    8541.4   10255.2    7356.3   25450.6   10285.7   24977.9
  9     8872.3    4801.7    5545.4    6787.2    4943.0   17396.3    7161.0
  10    5515.5   10091.8   11033.1   12904.6   15678.6   16426.6   26636.0
    year
age  2012      2013      2014      2015      2016      2017     
  1   935559.6 1043879.5 1156893.0  589017.9  636785.6  673808.7
  2   913529.8  753296.2  821582.4  848664.4  411697.5  453860.7
  3   546853.1  631453.0  513636.1  544320.8  553122.8  265193.9
  4   237762.2  320250.5  365774.9  306403.6  322653.2  314942.5
  5   141053.7  130354.0  176208.2  198204.4  169147.4  173058.4
  6    86642.8   74524.5   66570.5   93696.5  104632.0   91114.7
  7    27557.0   46362.5   38637.8   33923.4   50553.7   53183.4
  8    16856.1   17012.9   27120.6   20719.6   16331.3   27043.7
  9    17632.4   11797.7   11305.9   16428.4   11361.6    8266.6
  10   26154.0   33104.8   32958.6   31359.0   32552.1   28602.4

units:  1000 </code></pre>
<pre class="r"><code>harvest(ple4.LSvpa)[, ac(2004:range(ple4)[&quot;maxyear&quot;])]</code></pre>
<pre><code>An object of class &quot;FLQuant&quot;
, , unit = unique, season = all, area = unique

    year
age  2004    2005    2006    2007    2008    2009    2010    2011    2012   
  1  0.26215 0.28372 0.24382 0.20296 0.20776 0.24033 0.22356 0.15697 0.11669
  2  0.54513 0.47882 0.45856 0.45301 0.41162 0.34402 0.29292 0.26597 0.26929
  3  0.72533 0.61591 0.61364 0.62913 0.55866 0.44465 0.38623 0.40553 0.43508
  4  0.63651 0.59091 0.55053 0.52097 0.50340 0.49049 0.47955 0.48101 0.50102
  5  0.63407 0.58072 0.50767 0.45205 0.43174 0.43858 0.45970 0.49411 0.53801
  6  0.68809 0.57582 0.50191 0.45674 0.41616 0.38695 0.39693 0.45647 0.52530
  7  0.63370 0.49750 0.45191 0.44768 0.42871 0.39135 0.36398 0.36061 0.38229
  8  0.46306 0.37482 0.33195 0.31276 0.29758 0.28048 0.26210 0.24825 0.25681
  9  0.27920 0.25466 0.20003 0.15053 0.12790 0.12744 0.13887 0.15637 0.17965
  10 0.27920 0.25466 0.20003 0.15053 0.12790 0.12744 0.13887 0.15637 0.17965
    year
age  2013    2014    2015    2016    2017   
  1  0.13947 0.20983 0.25817 0.23864 0.19741
  2  0.28294 0.31169 0.32808 0.33983 0.40273
  3  0.44601 0.41661 0.42296 0.46319 0.57450
  4  0.49744 0.51272 0.49413 0.52295 0.57557
  5  0.57199 0.53160 0.53885 0.51865 0.60975
  6  0.55690 0.57416 0.51703 0.57670 0.58221
  7  0.43620 0.52315 0.63102 0.52558 0.54799
  8  0.30864 0.40128 0.50084 0.58086 0.36387
  9  0.20924 0.24468 0.28392 0.32874 0.39346
  10 0.20924 0.24468 0.28392 0.32874 0.39346

units:  f </code></pre>
<pre class="r"><code># Compare the results with previous fits.
plot(FLStocks(vpa=ple4.new2))</code></pre>
<p><img src="Stock_assessment_using_eXtended_Survivors_Analysis_with_FLXSA_files/figure-html/unnamed-chunk-8-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="flxsa" class="section level1">
<h1><code>FLXSA</code></h1>
<p>The Laurec-Shepherd method above is a relatively simple technique for tuning a VPA. XSA is a<br />
more sophisticated method that uses information on individual cohort sizes to estimate survivors at each age in the terminal population. Although the modelling approach is more involved the method requires the same input of catch numbers at age and indices of catch per unit effort and it retains at its core the basic <code>VPA</code> method. The details of the XSA method are too complex to show here, or to code individually as we have for the Laurec-Shepherd approach. Instead the <code>FLXSA</code> method has been developed as an additional package to <strong>FLAssess</strong>.</p>
<div id="the-flxsa-control-object" class="section level2">
<h2>The <code>FLXSA control</code> object</h2>
<p>The <code>FLXSA.control</code> object contains all of the user defined model settings for running an XSA analysis. It can be created in several different ways. The simplest method is to accept all of the default settings by calling the FLXSA.control function without any extra arguments:</p>
<pre class="r"><code>  FLXSA.control()</code></pre>
<pre><code>tol          1e-09 
maxit        30 
min.nse          0.3 
fse          0.5 
rage         0 
qage         10 
shk.n        TRUE 
shk.f        TRUE 
shk.yrs          5 
shk.ages         5 
window       100 
tsrange          20 
tspower          3 
vpa          FALSE </code></pre>
<p>Alternatively the default settings can be over-written by specifying values at the point of creation or by overwriting them afterwards.</p>
<pre class="r"><code>  ctrl &lt;- FLXSA.control(maxit = 50, qage = 8)
  ctrl &lt;- FLXSA.control()
  slot(ctrl, &#39;qage&#39;)  &lt;- as.integer(8)
  slot(ctrl, &#39;maxit&#39;) &lt;- as.integer(50)</code></pre>
<p>Note that in the example above, when modifying the control object after creation, it is necessary to coerce the values 8 and 50 to type integer. This is because the default type numeric cannot be used in this slot. Such coercion is not necessary when using the <code>FLXSA.control</code> function as this check is performed internally by the function. You can use the <code>getSlots</code> function to determine the class of object associated with any given slot.</p>
<pre class="r"><code> xsa.control &lt;- FLXSA.control(maxit = 50, fse = 2.5)
 ple4.xsa    &lt;- FLXSA(ple4, ple4.indices, xsa.control)
 ple4.xsa.t1 &lt;- FLXSA(ple4, ple4.indices[[1]], xsa.control)</code></pre>
<p>Once the control object has been created, the XSA analysis can be run as a one-line command. The ``<code>FLXSA</code> function returns an object of class <code>FLXSA</code> which extends the <code>FLAssess</code> class. The <code>FLXSA</code> object contains all of the information in the <code>FLAssess</code> class plus additional information specific to the XSA assessment method, such as the survivors estimates and their internal and external standard errors. The control object used for the assessment is also stored in the returned <code>FLXSA</code> object to provide a record of what settings were used for that particular run. All of the settings in the returned control object will remain the same except for the <code>maxit</code> slot that contains the maximum number of iterations for the analysis. This value will be overwritten with the actual number of iterations taken to reach convergence, if indeed the model had converged before the maximum number initially specified.</p>
</div>
<div id="xsa-results" class="section level2">
<h2>XSA Results</h2>
<p>Appart from the model diagnostics, the <code>FLXSA</code> method returns two important results, namely the estimated values of fishing mortality and population numbers at age. These are returned as <code>FLQuants</code> and are stored in the <code>harvest</code> and <code>stock.n</code> slots, respectively, of the <code>FLXSA</code> object. These estimated values can be very easilly read back into an <code>FLStock</code> object using the <code>+</code> operator. Once the results have been read back into a FLStock object we can look at some of the key information such as SSB, recruitment and mean fishing mortality values. But before concentrating too much on the results of the assessment it is advisable to first investigate some of the model diagnostics.</p>
<pre class="r"><code>ple4.new  &lt;- ple4 + ple4.xsa
ple4.ssb  &lt;- ssb(ple4.new)
ple4.rec  &lt;- rec(ple4.new)
ple4.fbar &lt;- fbar(ple4.new)</code></pre>
</div>
<div id="xsa-diagnostics" class="section level2">
<h2>XSA Diagnostics</h2>
<p>There are many diagnostic checks that one might be interested in conducting to examine the model fit. The first might be to see if the model has reached convergence within the specified number of iterations.</p>
<pre class="r"><code> slot(slot(ple4.xsa, &quot;control&quot;), &quot;maxit&quot;)</code></pre>
<pre><code>[1] 50</code></pre>
<p>Additionally one can check for discrepancies between the internal and external standard errors of the survivors estimates. Very often plots of the catchability residuals are made to inspect for any obvious trends or departures from the assumption of constant catchability over time. Some examples of these plots and details of their creation from FLR objects are provided below but you should also consult the tutorial on lattice plotting and advanced graphics for FLR to see examples of other ways to graphically display your data.</p>
<p>There are several ways to access diagnostic information about your fitted XSA model. The easiest is perhaps to use the <code>diagnostics</code> function, which will replicate the diagnostic output produced by the original VPA suite (developed in the early 1990’s). Note that this function merely outputs the results to the screen and no object is created by the method. The function was created to allow the user to cut and paste the information from the console to a report. The output can be quite long, particularly if the assessment comprises a large number of ages and many tuning indices. The standard output can be divided roughly into eight sections each providing different information about the model and the fit. These sections comprise the model dimensions; parameter settings; regression weights; the estimated fishing mortalities and population numbers for the last 10 years; the aggregated survivors estimates; the log catchability residuals for each of the tuning indices and finally the individual survivors estimates for each year-class represented in the terminal year.</p>
<p>In order to make this document more readable we will print out only a few sections of the diagnostic output at a time. We can do this by passing a vector of <code>TRUE</code> and <code>FALSE</code> values to the sections argument of the <code>diagnostics</code> method. By default all sections are set to <code>TRUE</code> so that all of the information is output to the screen. In order to reduce the quantity of output further<br />
we will run a new XSA for a reduced number of ages and with only one tuning index and will start by outputting only the dimension information and the parameter settings from our diagnostics.</p>
<pre class="r"><code> ple4.xsa2 &lt;- FLXSA(trim(ple4, age = 1:7), ple4.indices[[3]],
     xsa.control)
 diagnostics(ple4.xsa2, sections = c(T, T, rep(F, 6)))</code></pre>
<pre><code>FLR XSA Diagnostics 2021-07-04 22:08:06

CPUE data from indices

Catch data for 61 years 1957 to 2017. Ages 1 to 7.

  fleet first age last age first year last year alpha beta
1   SNS         1        6       1970      2017  &lt;NA&gt; &lt;NA&gt;


 Time series weights :

    Tapered time weighting applied
   Power =   3 over  20 years

 Catchability analysis :

     Catchability independent of size for all ages

     Catchability independent of age for ages &gt;   6 

 Terminal population estimation :

     Survivor estimates shrunk towards the mean F
    of the final   5 years or the  5 oldest ages.

    S.E. of the mean to which the estimates are shrunk =   2.5 
 
    Minimum standard error for population
    estimates derived from each fleet =  0.3 

    prior weighting not applied</code></pre>
<p>Next we can output the regression weights and the fishing mortalities and population numbers for the last 10 years and also the aggregated survivors estimates.</p>
<pre class="r"><code> diagnostics(ple4.xsa2, sections = c(F, F, T, T, T, T, F, F))</code></pre>
<pre><code>Regression weights
     year
age    2008 2009  2010  2011  2012  2013 2014  2015 2016 2017
  all 0.751 0.82 0.877 0.921 0.954 0.976 0.99 0.997    1    1


 Fishing mortalities
   year
age  2008  2009  2010  2011  2012  2013  2014  2015  2016  2017
  1 0.207 0.247 0.200 0.124 0.105 0.104 0.147 0.122 0.183 0.107
  2 0.443 0.343 0.304 0.231 0.204 0.249 0.218 0.211 0.136 0.284
  3 0.535 0.499 0.385 0.429 0.359 0.306 0.349 0.261 0.254 0.171
  4 0.550 0.456 0.580 0.479 0.549 0.372 0.295 0.380 0.262 0.242
  5 0.570 0.506 0.410 0.689 0.535 0.674 0.340 0.240 0.346 0.223
  6 0.692 0.609 0.498 0.383 1.007 0.552 0.786 0.265 0.182 0.312
  7 0.692 0.609 0.498 0.383 1.007 0.552 0.786 0.265 0.182 0.312


 XSA population number (Thousand)
      age
year         1       2      3      4      5      6      7
  2008  873829  762854 304706 129307  89155  19273  30076
  2009  801925  642724 443318 161500  67535  45627  11911
  2010 1207505  566603 412620 243597  92626  36835  30880
  2011 1468479  894604 378145 254039 123415  55638  25433
  2012 1036439 1173206 642406 222804 142348  56052  13725
  2013 1382295  844446 865899 406006 116431  75436  38620
  2014 1603721 1127599 595646 577062 253287  53708  28858
  2015 1171171 1252542 820617 379995 388764 163122  68342
  2016  810347  938140 917890 571988 235246 276692 124405
  2017 1195955  610611 741191 644206 398100 150631  83772


 Estimated population abundance at 1st Jan  2018 
      age
year   1      2      3      4      5      6     7
  2018 0 973125 416096 565666 457969 288826 99986</code></pre>
<p>And finally we can output the catchability residuals and the individual survivors estimates. Note that very little thought went into the parameter settings for this particular model fit so please don’t interrogate the output presented here too closely. Also note that we do not normally expect the diagnostics output to be broken up as we have here. We present it in this way purely to make it more presentable in this document. By default all sections are set to <code>TRUE</code> so it is very likely that you won’t need to give this argument at all when calling the diagnostics method.</p>
<pre class="r"><code> diagnostics(ple4.xsa2, sections = c(F, F, F, F, F, F, T, T))</code></pre>
<pre><code>

 Fleet:  SNS 

 Log catchability residuals.

   year
age   1970   1971   1972   1973   1974   1975   1976  1977   1978   1979   1980
  1  0.113  0.922  1.057  1.332  0.162  0.239  0.132 0.504  0.375  0.715  1.506
  2  1.929  2.996  2.471  1.908  1.773  1.370  0.527 1.119  2.057  1.965  2.128
  3  2.505  1.262  2.440  1.875  1.747  2.565  0.449 1.537  0.203  1.412  0.461
  4  2.032  0.150 -0.335  1.402  0.867  0.156  0.084 1.271  0.224  0.742  0.603
  5  1.015  0.223  0.938 -1.072  0.773 -0.406     NA 1.019 -0.233 -0.730 -0.013
  6 -0.364 -0.634     NA -1.346 -1.382     NA -1.832    NA -1.264  0.206 -0.981
   year
age   1981   1982   1983   1984   1985   1986   1987   1988  1989  1990   1991
  1  0.677  1.062  0.709  1.068  0.283  0.598  0.360  0.503 0.774 0.601  1.535
  2  2.248  1.485  1.299  1.390  1.773  0.871  1.462  1.418 1.655 1.101  1.644
  3  0.896  1.009 -0.655  0.946  0.895  0.689  0.488  2.003 1.669 1.332  0.891
  4 -0.702  0.035 -0.523 -1.132  0.217 -0.210  0.250  1.910 2.710 1.285  1.529
  5  0.032 -1.108 -1.516     NA -0.925 -1.052 -0.653  0.559 1.490 0.998  0.538
  6 -1.114 -0.759 -2.432     NA -2.783 -1.378 -1.131 -1.053 1.306 0.184 -0.270
   year
age  1992   1993   1994   1995   1996   1997   1998  1999   2000   2001   2002
  1 1.481  1.164  0.973  0.739  0.469  1.101  1.119 1.289  0.770  0.433  0.425
  2 1.977  1.774  1.513  0.859  1.694  0.613  1.815 1.706  0.462  0.513  0.003
  3 1.449  0.786  0.780  0.371  1.489  0.319  2.106 2.528  0.567 -0.096 -0.351
  4 1.257 -0.400 -0.478 -0.056 -0.389 -0.676 -0.350 1.683  1.319  0.171 -0.554
  5 0.811  0.024 -0.746 -0.041  0.386     NA -0.613 0.081 -1.638  2.240  0.227
  6 0.111  0.191 -2.608     NA     NA -0.322     NA    NA -1.035  0.315 -0.209
   year
age 2003   2004   2005   2006   2007   2008   2009   2010   2011   2012   2013
  1   NA  0.391  0.183  0.316  0.100  0.310  0.435 -0.226 -0.046 -0.847 -0.176
  2   NA  0.478  0.017  0.232  0.452  0.312  0.122  0.113 -0.856 -0.206  0.186
  3   NA  0.721 -0.240 -0.024 -0.691  0.323 -0.019  0.045 -0.378 -0.162  0.378
  4   NA  0.125  1.165  0.161 -0.650  0.883 -0.955 -0.909 -0.711 -0.442  0.486
  5   NA -0.088 -0.421  0.641     NA  0.085 -0.213 -1.290  0.412 -0.533  0.853
  6   NA  0.052  0.028     NA -0.200 -0.023     NA     NA  0.129 -0.063  0.049
   year
age   2014  2015   2016   2017
  1 -0.176 0.086  0.021  0.006
  2 -0.417 0.276 -0.215 -0.031
  3 -0.376 0.539 -0.128  0.137
  4  0.148 0.668  0.264  0.154
  5 -0.587 0.152  0.837 -0.213
  6 -0.086 0.219 -0.068  0.009


 Mean log catchability and standard error of ages with catchability 
 independent of year class strength and constant w.r.t. time 

                1       2       3       4       5       6
Mean_Logq -4.1782 -5.5729 -6.3623 -7.0081 -7.4844 -7.3835
S.E_Logq   0.5162  0.8819  0.8866  0.8817  0.8357  0.9003


 Terminal year survivor and F summaries: 
 
 ,Age 1 Year class =2016 

source 
     scaledWts survivors yrcls
SNS      0.977    978305  2016
fshk     0.023    773780  2016

 ,Age 2 Year class =2015 

source 
     scaledWts survivors yrcls
SNS      0.969    403220  2015
fshk     0.031    604524  2015

 ,Age 3 Year class =2014 

source 
     scaledWts survivors yrcls
SNS      0.971    648476  2014
fshk     0.029    293770  2014

 ,Age 4 Year class =2013 

source 
     scaledWts survivors yrcls
SNS      0.913    533680  2013
fshk     0.087    277605  2013

 ,Age 5 Year class =2012 

source 
     scaledWts survivors yrcls
SNS      0.906    233051  2012
fshk     0.094    134437  2012

 ,Age 6 Year class =2011 

source 
     scaledWts survivors yrcls
SNS      0.981    100592  2011
fshk     0.019    160164  2011</code></pre>
<p>Remember that the diagnostics method will only output text to the console, enabling you to copy and paste the output to a report or other document. If you want to access the diagnostic data you will need to access the specific slots of the returned <code>FLXSA</code> object. The information that you will requie is contained in various slots. The individual estimates of population number from each source (ie. tuning series and F shrinkage) and their individual weightings are stored as a dataframe in the <code>diagnostics</code> slot of the returned object. Other slots contain the internal and external standard errors; the log catchability residuals. For a more thorough description of the XSA diagnostics you should consult the VPA users manaual.</p>
</div>
<div id="plotting-diagnostics" class="section level2">
<h2>Plotting Diagnostics</h2>
<p>Very often the quickest and simplest way to determine the fit of the model is through visual inspection of the various diagnostic outputs.</p>
<p>The default plot for ’‘’FLXSA’’’ class shows the weight given to each of the indices, incluiding the shrinkage, to estimate total numbers at age along ages and years. The size of the bubbles in the plot is proportional to the weight given to the index to estimate the terminal numbers at age. The rows corresponds with the indices used and the columns with age classes. The y axis represent the estimate of numbers at age obtained from each index.</p>
<pre class="r"><code> plot(ple4.xsa2)</code></pre>
<p><img src="Stock_assessment_using_eXtended_Survivors_Analysis_with_FLXSA_files/figure-html/unnamed-chunk-17-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Below we provide examples of how to extract the relevant information from the return <code>FLXSA</code> object and to plot it using a variety of lattice functions available to <code>R</code>. We start by plotting the log catchability residuals at age from each of the three tuning series. The data are stored as an <code>FLQuants</code> object in the index.res slot of the <code>FLXSA</code> object. First we need to assign names to each of the <code>FLQuant</code> objects so we know which fleet they represent.</p>
<pre class="r"><code> names(ple4.xsa@index.res) &lt;- names(ple4.indices)
 plot(xyplot(data ~ year | ac(age) + qname, data = index.res(ple4.xsa),
     panel = function(x, y, ...) {
     panel.xyplot(x, y, ...)
     panel.loess(x, y, ...)
     panel.abline(h = 0, col = &quot;grey&quot;, lty = 2)
 }))</code></pre>
<p><img src="Stock_assessment_using_eXtended_Survivors_Analysis_with_FLXSA_files/figure-html/unnamed-chunk-18-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>A simple comparison of the terminal year survivors estimates can be obtained from the information stored in the diagnostics slot of the <code>FLXSA</code> object. In the following example we first extract the information relevant to the survivors estimates in the final year and store it as a temporary object. The weights values contained in this data set are the raw fleet based weights that have been calculated from the standard errors of the fleet based survivors estimates at each age in the cohort. To aid visualisation and to see the relative contribution of each fleets estimate to the final estimated value of survivors we re-scale the weights to a maximum value of 1 and plot both the fleet based survivors estimates from each fleet and their scaled weight. The results show relatively consistent estimates of survivors from all fleets across most ages. The scaled weights show the some series to have the greatest influence on the terminal estimates at the younger ages whilst others have greater influence at older ages and that throughout all ages F shrinkage recieves very little weighting.</p>
<pre class="r"><code> diag &lt;- slot(ple4.xsa, &quot;diagnostics&quot;)[is.element(slot(ple4.xsa,
     &quot;diagnostics&quot;)$year, 2008), ]
 diag &lt;- cbind(diag, w.scaled = diag$w/rep(tapply(diag$w, diag$yrcls, sum),
     c(table(diag$yrcls))))
 nplot &lt;- barchart(ac(yrcls) ~ nhat, groups = source, data = diag,
     col = grey(c(0.1, 0.6, 0.3, 0.8)), main = &quot;N Estimates&quot;,
     ylab = &quot;Year Class&quot;, key = list(x = 0.3, y = 0.25, text = list(legend =
rev(c(&quot;BTS-Isis&quot;,
         &quot;BTS-Tridens&quot;, &quot;fshk&quot;, &quot;SNS&quot;))), rectangles = list(col =
grey(rev(c(0.1,
         0.6, 0.3, 0.8))))))
 wplot &lt;- barchart(ac(yrcls) ~ w.scaled, groups = source, data = diag,
     col = grey(c(0.1, 0.6, 0.3, 0.8)), main = &quot;Scaled Weights&quot;,
     ylab = &quot;&quot;, xlab = &quot;Relative Weight&quot;)
 print(nplot, position = c(0, 0, 0.5, 1), more = TRUE)
 print(wplot, position = c(0.5, 0, 1, 1))</code></pre>
<p><img src="Stock_assessment_using_eXtended_Survivors_Analysis_with_FLXSA_files/figure-html/unnamed-chunk-19-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="sensitivity-to-different-model-settings." class="section level2">
<h2>Sensitivity to different model settings.</h2>
<p>The simplified calling format of <code>FLXSA</code> makes it very easy to run multiple analyses to investigate model sensitivity to parameter settings. A wide variety of such investigations are possible. In this simple example we will look at the effect that different F shrinkage standard errors have on the terminal estimates of fishing mortality. We start by creating a vector of F shrinkage values to be used in the anlyses and by creating an FLQuant with sufficient dimensions to store the results. To do this we use the propagate function to extend an FLQuant in the 6th dimension by the number of runs that we are going to perform. The estimates of fishing mortality for each XSA run are stored in the FLQuant using the 6th dimension to hold each iteration. The results show little sensitivity to increasing F shrinkage values at values between 1.0 and 2.5 .</p>
<pre class="r"><code> fsevals &lt;- seq(0.5, 2.5, by = 0.5)
 res &lt;- propagate(harvest(ple4), length(fsevals))
 for (i in 1:length(fsevals)) {
     xsa.control &lt;- FLXSA.control(fse = fsevals[i])
     iter(res, i) &lt;- harvest(FLXSA(ple4, ple4.indices, xsa.control))
 }
 plot(xyplot(data ~ year | age, groups = iter, data = res, type = &quot;l&quot;,
     col = &quot;black&quot;, xlim = c(1990:2010)))</code></pre>
<p><img src="Stock_assessment_using_eXtended_Survivors_Analysis_with_FLXSA_files/figure-html/unnamed-chunk-20-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="retrospective-analyses" class="section level2">
<h2>Retrospective Analyses</h2>
<p>An important diagnostic check is to see how the estimated values vary as the time series of the input data changes. We can make use of existing <code>R</code> functions to apply the same assessment model to successively truncated the time series of input data. In this example we are using <code>window</code> to truncate the <code>FLStock</code> object to the specified year range, the <code>+</code> operator to pass the results of the XSA into the <code>FLStock</code> object and the <code>tapply</code> function to perform this action over the year range <code>2004:2008</code>. Note that the resulting object, called <code>ple4.ret</code>, is of class <code>FLStocks</code> ie. a list of <code>FLStock</code> objects, each one having a separate year range.</p>
<pre class="r"><code>retro.years &lt;- 2013:2017
ple4.retro &lt;- tapply(retro.years, 1:length(retro.years), function(x){
    window(ple4,end=x)+FLXSA(window(ple4,end=x),ple4.indices)
})

# coerce into FLStocks object
ple4.retro &lt;- FLStocks(ple4.retro)
# full retrospective summary plot
ple4.retro@names=ac(c(retro.years))###Add years to legend
plot(ple4.retro)</code></pre>
<p><img src="Stock_assessment_using_eXtended_Survivors_Analysis_with_FLXSA_files/figure-html/unnamed-chunk-21-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="more-information" class="section level1">
<h1>More information</h1>
<ul>
<li>You can submit bug reports, questions or suggestions on this tutorial at <a href="https://github.com/flr/doc/issues" class="uri">https://github.com/flr/doc/issues</a>.</li>
<li>Or send a pull request to <a href="https://github.com/flr/doc/" class="uri">https://github.com/flr/doc/</a></li>
<li>For more information on the FLR Project for Quantitative Fisheries Science in R, visit the FLR webpage, <a href="http://flr-project.org" class="uri">http://flr-project.org</a>.</li>
</ul>
<div id="software-versions" class="section level2">
<h2>Software Versions</h2>
<ul>
<li>R version 4.1.0 (2021-05-18)</li>
<li>FLCore: 2.6.16</li>
<li>FLXSA: 2.6.4</li>
<li>FLAssess: 2.6.3</li>
<li><strong>Compiled</strong>: Sun Jul 4 22:08:34 2021</li>
</ul>
</div>
<div id="license" class="section level2">
<h2>License</h2>
<p>This document is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0">Creative Commons Attribution-ShareAlike 4.0 International</a> license.</p>
</div>
<div id="author-information" class="section level2">
<h2>Author information</h2>
<p><strong>Dorleta Garcia</strong> AZTI. Marine Reserach Unit. Txatxarramendi Ugartea z/g, 48395, Sukarrieta, Basque Country, Spain.</p>
<p><strong>Alessandro MANNINI</strong>. European Commission, DG Joint Research Centre, Directorate D - Sustainable Resources, Unit D.02 Water and Marine Resources, Via E. Fermi 2749, 21027 Ispra VA, Italy. <a href="https://ec.europa.eu/jrc/" class="uri">https://ec.europa.eu/jrc/</a></p>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-quinn1999">
<p>II, Terrance J. Quinn, and Richard B. Deriso. 1999. <em>Quantitative Fish Dynamics</em>. New York: Oxford University Press.</p>
</div>
<div id="ref-shepherd1999">
<p>Shepherd, J. G. 1999. “Extended Survivors Analysis: An Improved Method for the Analysis of Catch-at-Age Data and Abundance Indices.” <em>ICES Journal of Marine Science</em> 56: 584–91.</p>
</div>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
